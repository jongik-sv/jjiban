# 기본설계: 워크플로우 타입 및 스토어

**Task ID**: TSK-02-03
**문서 버전**: 1.0
**작성일**: 2025-12-17
**참조**: PRD 4.5, 5.4, 5.5

---

## 1. 개요

### 1.1 목적

워크플로우 명령어 실행을 위한 타입 시스템과 상태 관리 아키텍처를 설계합니다. 터미널 세션과 워크플로우 실행 상태를 프론트엔드에서 체계적으로 관리할 수 있는 기반을 구축합니다.

### 1.2 범위

**포함:**
- TypeScript 인터페이스 정의 (터미널, 워크플로우)
- Pinia 스토어 설계 (terminal.ts, workflow.ts)
- Vue Composable 설계 (useTerminal, useWorkflow)

**제외:**
- 실제 API 구현 (TSK-01-03, TSK-02-02 범위)
- UI 컴포넌트 구현 (TSK-01-02, TSK-02-01 범위)

### 1.3 핵심 가치

| 가치 | 설명 |
|------|------|
| 타입 안정성 | TypeScript로 런타임 에러 사전 방지 |
| 상태 중앙화 | Pinia로 일관된 상태 관리 |
| 재사용성 | Composable로 로직 공유 |
| 테스트 용이성 | 명확한 인터페이스로 Mock 데이터 생성 용이 |

---

## 2. 비즈니스 요구사항

### 2.1 터미널 세션 관리

**비즈니스 시나리오:**

사용자가 Task 상세에서 워크플로우 명령어 버튼을 클릭하면:

1. 터미널 세션이 없으면 새로 생성
2. 터미널 세션이 있으면 재사용
3. 명령어 프롬프트를 터미널에 전송
4. 터미널 출력을 실시간으로 화면에 표시
5. 명령어 완료 시 세션 상태 업데이트

**관리 요구사항:**

| 항목 | 요구사항 |
|------|----------|
| 세션 생성 | Task당 1개 세션 (필요시 생성) |
| 세션 상태 | 연결/실행/완료/에러 상태 추적 |
| 세션 정리 | 브라우저 탭 닫힘 시 자동 정리 |
| 에러 처리 | 연결 실패 시 재시도 메커니즘 |

### 2.2 워크플로우 명령어 관리

**비즈니스 시나리오:**

사용자가 워크플로우 명령어 버튼을 보면:

1. 현재 Task 상태에서 실행 가능한 명령어만 표시 (다른 버튼은 비활성화)
2. 실행 중인 명령어가 있으면 중복 실행 방지
3. 명령어 실행 중 스피너 표시
4. 완료 시 성공/실패 알림

**명령어 가용성 규칙:**

| Task 상태 | 사용 가능 명령어 (development) |
|-----------|-------------------------------|
| `[ ]` | start |
| `[bd]` | ui, draft |
| `[dd]` | review, apply, build |
| `[im]` | test, audit, patch, verify |
| `[vf]` | done |

### 2.3 실시간 상태 동기화

**비즈니스 시나리오:**

여러 브라우저 탭/창에서 동일한 프로젝트를 열 때:

1. 한 탭에서 워크플로우 실행 시작
2. 다른 탭에서 WBS 트리에 스피너 표시 (30초 폴링)
3. 명령어 완료 시 모든 탭에서 상태 업데이트 반영

**동기화 메커니즘:**

- Execution Store: 30초 폴링으로 실행 중인 Task 목록 조회
- WBS Store: Task 상태 변경 시 자동 리프레시
- 낙관적 업데이트: 로컬 상태 즉시 반영 후 서버 확인

---

## 3. 데이터 모델

### 3.1 터미널 세션 모델

**개념:**

터미널 세션은 node-pty로 생성된 가상 터미널 프로세스를 나타냅니다. 각 세션은 고유한 PID를 가지며, Task와 선택적으로 연결됩니다.

**상태 전이:**

```
[미생성] → [연결 중] → [연결됨] → [실행 중] → [완료]
                ↓              ↓
            [에러]         [에러]
```

**라이프사이클:**

| 단계 | 트리거 | 결과 |
|------|--------|------|
| 생성 | 워크플로우 버튼 클릭 | POST /api/terminal/session |
| 연결 | SSE 스트림 열기 | 터미널 출력 수신 시작 |
| 입력 | 사용자 키 입력 | POST /api/terminal/session/:id/input |
| 종료 | 사용자 명시적 종료 또는 프로세스 종료 | DELETE /api/terminal/session/:id |

### 3.2 워크플로우 실행 모델

**개념:**

워크플로우 실행은 특정 Task에 대한 워크플로우 명령어의 실행 인스턴스를 나타냅니다. 실행 정보는 서버 메모리에 유지되며, 클라이언트에서 폴링으로 조회합니다.

**실행 흐름:**

```
[대기] → [프롬프트 생성] → [터미널 입력] → [실행 중] → [완료]
                                                    ↓
                                                [에러]
```

**중복 실행 방지:**

- 동일 Task에 대해 이미 실행 중인 명령어가 있으면 버튼 비활성화
- 서버 측에서도 중복 실행 차단 (ExecutionManager)
- Stale Execution: 1시간 경과한 실행은 자동 정리

### 3.3 명령어 메타데이터 모델

**개념:**

각 워크플로우 명령어는 메타데이터를 가지며, Task의 카테고리와 상태에 따라 가용성이 결정됩니다.

**명령어 속성:**

| 속성 | 설명 | 예시 |
|------|------|------|
| name | 명령어 이름 | "start", "build", "verify" |
| label | 버튼 레이블 | "시작", "구현", "검증" |
| icon | PrimeIcon | "pi-play", "pi-code", "pi-check" |
| severity | 버튼 색상 | "primary", "success", "danger" |
| availableStatuses | 사용 가능 상태 목록 | `["[ ]"]`, `["[dd]"]` |
| categories | 사용 가능 카테고리 | `["development"]` |

---

## 4. 상태 관리 전략

### 4.1 Store 분리 원칙

**Terminal Store:**
- **책임**: 터미널 세션의 라이프사이클 관리
- **범위**: 세션 생성/종료, 입출력, 리사이즈

**Workflow Store:**
- **책임**: 워크플로우 명령어 실행 관리
- **범위**: 명령어 실행, 가용성 조회, 실행 취소

**Execution Store (기존):**
- **책임**: 실행 상태 추적 (WBS 트리 스피너용)
- **범위**: 실행 중인 Task 목록 폴링

**분리 이유:**

| 이유 | 설명 |
|------|------|
| 단일 책임 원칙 | 각 Store가 하나의 역할만 수행 |
| 테스트 용이성 | 독립적으로 테스트 가능 |
| 재사용성 | Terminal Store는 워크플로우 외에도 사용 가능 |
| 성능 최적화 | 필요한 Store만 선택적으로 사용 |

### 4.2 Composable 역할

**useTerminal:**
- Terminal Store의 로직을 컴포넌트에서 사용하기 쉽게 추상화
- 세션 생성/종료, 입력 전송, 출력 구독 로직 캡슐화
- 에러 처리 및 알림 로직 통합

**useWorkflow:**
- Workflow Store의 로직을 컴포넌트에서 사용하기 쉽게 추상화
- 명령어 실행, 가용성 필터링 로직 캡슐화
- Terminal Store와의 통합 로직 (세션 생성 → 명령어 실행)

**Composable vs Store:**

| 구분 | Store | Composable |
|------|-------|-----------|
| 목적 | 상태 중앙 관리 | 로직 재사용 |
| 반응성 | Pinia 반응성 시스템 | Vue Composition API |
| 사용 위치 | 어디서든 import | 컴포넌트 내부 |
| 테스트 | Store 단위 테스트 | Composable 단위 테스트 |

---

## 5. 사용자 시나리오

### 5.1 시나리오 1: 워크플로우 명령어 실행

**사용자 행동:**

1. 사용자가 Task TSK-01-01을 선택합니다.
2. Task 상세 패널에서 워크플로우 액션 바를 확인합니다.
3. "구현" 버튼을 클릭합니다.

**시스템 동작:**

1. `useWorkflow.executeCommand('build')`가 호출됩니다.
2. Terminal Store에서 세션이 없으면 생성합니다.
3. Workflow Store에서 프롬프트 문자열 `/wf:build TSK-01-01`을 생성합니다.
4. Terminal Store에서 프롬프트를 터미널에 입력합니다.
5. Execution Store에서 실행 시작을 등록합니다.
6. WBS 트리에 스피너가 표시됩니다.
7. 터미널 출력이 실시간으로 표시됩니다.
8. 명령어 완료 시 성공 알림이 표시됩니다.

### 5.2 시나리오 2: 중복 실행 방지

**사용자 행동:**

1. 사용자가 Task TSK-01-01에서 "구현" 버튼을 클릭합니다.
2. 명령어가 실행 중입니다.
3. 사용자가 다시 "구현" 버튼을 클릭하려고 합니다.

**시스템 동작:**

1. Execution Store의 `isExecuting('TSK-01-01')`이 true를 반환합니다.
2. "구현" 버튼이 비활성화됩니다.
3. 버튼에 마우스를 올리면 "이미 실행 중입니다" 툴팁이 표시됩니다.

### 5.3 시나리오 3: 다중 브라우저 탭 동기화

**사용자 행동:**

1. 사용자가 브라우저 탭 A에서 워크플로우를 실행합니다.
2. 사용자가 브라우저 탭 B를 엽니다.

**시스템 동작:**

1. 탭 B에서 Execution Store가 30초마다 폴링합니다.
2. 서버에서 실행 중인 Task 목록을 조회합니다.
3. 탭 B의 WBS 트리에도 스피너가 표시됩니다.
4. 탭 A에서 명령어가 완료되면 서버 상태가 업데이트됩니다.
5. 탭 B의 다음 폴링에서 스피너가 사라집니다.

---

## 6. 에러 처리

### 6.1 터미널 에러

| 에러 상황 | 처리 방법 |
|-----------|-----------|
| 세션 생성 실패 | 에러 알림 표시, 재시도 버튼 제공 |
| SSE 연결 끊김 | 자동 재연결 (3회 시도) |
| 입력 전송 실패 | 에러 알림 표시, 입력 버퍼 유지 |
| 세션 종료 실패 | 로컬 상태만 정리, 서버는 타임아웃으로 정리 |

### 6.2 워크플로우 에러

| 에러 상황 | 처리 방법 |
|-----------|-----------|
| 명령어 실행 실패 | 에러 알림 표시, 실행 상태 즉시 정리 |
| 가용 명령어 조회 실패 | 기본 명령어 목록 사용 (클라이언트 폴백) |
| 중복 실행 시도 | 버튼 비활성화, 툴팁 표시 |
| Stale Execution | 서버 측에서 1시간 후 자동 정리 |

### 6.3 네트워크 에러

| 에러 상황 | 처리 방법 |
|-----------|-----------|
| API 타임아웃 | 3초 타임아웃, 재시도 메커니즘 |
| 네트워크 끊김 | 오프라인 알림, 재연결 시 자동 복구 |
| 서버 재시작 | 세션 재생성, 실행 상태 재조회 |

---

## 7. 성능 고려사항

### 7.1 터미널 출력 렌더링

**문제:**
- 터미널 출력이 초당 수백 줄 생성될 수 있습니다.
- 모든 출력을 즉시 렌더링하면 브라우저가 느려집니다.

**해결:**
- xterm.js의 버퍼 관리 기능 활용
- 출력 버퍼: 세션당 10,000줄 제한
- 스크롤 최적화: Virtual Scrolling

### 7.2 폴링 최적화

**문제:**
- 30초마다 폴링하면 서버 부하가 증가합니다.

**해결:**
- 실행 중인 세션이 없으면 폴링 중지
- 포그라운드 탭에서만 폴링 (Visibility API)
- 서버 캐싱: 실행 상태는 메모리에 유지

### 7.3 Store 메모리 관리

**문제:**
- 많은 세션을 생성하면 메모리 사용량이 증가합니다.

**해결:**
- 종료된 세션은 Map에서 제거
- 브라우저 탭 닫힘 감지 시 정리 (beforeunload)
- 최대 동시 세션 수 제한 (10개)

---

## 8. 보안 고려사항

### 8.1 터미널 입력 검증

**위험:**
- 사용자가 임의의 명령어를 터미널에 입력할 수 있습니다.

**대응:**
- 서버 측에서 허용된 `/wf:*` 명령어만 실행
- XSS 방지: DOMPurify로 출력 정화
- CSRF 방지: Nuxt의 기본 CSRF 토큰 사용

### 8.2 세션 접근 제어

**위험:**
- 다른 사용자의 터미널 세션에 접근할 수 있습니다.

**대응:**
- 세션 ID에 사용자 정보 포함 (현재는 단일 사용자)
- 향후 다중 사용자 지원 시 인증 토큰 검증

---

## 9. 확장성 고려사항

### 9.1 다중 터미널 탭 (3차 범위)

**현재 설계:**
- Task당 1개 세션

**확장 방안:**
- Terminal Store의 `sessions` Map에 여러 세션 저장
- 활성 세션 ID를 `activeSessionId`로 관리
- 탭 UI 추가 (TerminalDialog에 TabView)

### 9.2 터미널 히스토리 저장 (3차 범위)

**현재 설계:**
- 세션 종료 시 출력 삭제

**확장 방안:**
- 출력 내용을 서버에 저장 (파일 또는 DB)
- History API로 이전 실행 내역 조회
- TerminalView에서 히스토리 표시

### 9.3 WebSocket 지원 (3차 범위)

**현재 설계:**
- SSE (단방향) + POST API (입력)

**확장 방안:**
- WebSocket으로 양방향 통신
- Nitro WebSocket 플러그인 사용
- 연결 상태 관리 로직 추가

---

## 10. 다음 단계

### 10.1 상세설계 작성

본 기본설계를 바탕으로 다음 항목을 포함한 상세설계 문서를 작성합니다:

- TypeScript 인터페이스 정의 (완전한 코드)
- Pinia Store 구조 (State, Getters, Actions)
- Composable 함수 시그니처
- API 호출 흐름 다이어그램
- 테스트 시나리오

### 10.2 구현 순서

1. types/terminal.ts 작성
2. stores/terminal.ts 작성
3. stores/workflow.ts 작성
4. composables/useTerminal.ts 작성
5. composables/useWorkflow.ts 작성
6. 단위 테스트 작성

---

## 변경 이력

| 버전 | 날짜 | 변경 내용 |
|------|------|-----------|
| 1.0 | 2025-12-17 | 초안 작성 |
